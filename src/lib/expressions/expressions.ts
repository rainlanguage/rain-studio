import { matchContracts, matchInterpreters } from '$lib/match-addresses';
import { supabaseClient as _supabaseClient } from '$lib/supabaseClient';
import type { Database } from '$lib/types/generated-db-types';
import type { ExpressionInsert, ExpressionRow, ExpressionRowFull } from '$lib/types/types';
import { QueryAccountsFromArray, QueryExpression, Subgraphs } from '$lib/utils';
import type { TypedSupabaseClient } from '@supabase/auth-helpers-sveltekit/dist/types';
import type { PostgrestSingleResponse } from '@supabase/supabase-js';
import { createClient } from '@urql/core';
import { error as sveltekitError } from '@sveltejs/kit';
import { ethers } from 'ethers';
import { toast } from '@zerodevx/svelte-toast';

/**
 * Create a new blank expression, with no raw string, notes or name.
 *
 * @param expression - the expression
 */
export const createNewExpression = async (
	expression: Omit<ExpressionInsert, 'raw_expression' | 'notes' | 'name'>
) => {
	const _expression = { ...expression, notes: '', raw_expression: '', name: 'Untitled expression' };
	return await saveExpression(_expression);
};

/**
 * Save an expression
 *
 * @param expression - the expression
 */
export const saveExpression = async (
	expression: ExpressionInsert
): Promise<PostgrestSingleResponse<ExpressionRow>> => {
	// these fields are automatically generated by the db
	delete expression.id;
	delete expression.sharable_slug;
	delete expression.user_id;

	// ensuring the new expression is private by default
	expression.public = false;

	const newExpression = await _supabaseClient
		.from('draft_expressions_w')
		.insert(expression)
		.select('*')
		.single();
	return newExpression;
};

/**
 * Save a copy of an expression, this updates the name to "Copy of {expression_name}"
 *
 * @param expression - the expression
 */
export const saveExpressionCopy = async (
	expression: ExpressionInsert
): Promise<ReturnType<typeof saveExpression>> => {
	const expressionCopy = { ...expression, name: `Copy of ${expression.name}` };
	return await saveExpression(expressionCopy);
};

/**
 * Convert an expression from the ExpressionRowFull type to the ExpressionInsert type
 * This is necessary, because the ExpressionRowFull type is fully joined on contract, interpreter etc,
 * however when we insert we just need id's for those fields.
 */
export const flattenExpression = (expression: ExpressionRowFull): ExpressionInsert => {
	return {
		...expression,
		contract: expression?.contract?.id,
		interpreter: expression?.interpreter?.id,
		user_id: expression?.user_id.id
	};
};
/**
 * Gets all deployed expressions for a user.
 * This function gets all the user's linked wallets and fetches the deployed expressions from the subgraph.
 * It then matches the contract sender and interpreter from the db for each expression and returns the combined results.
 *
 * @param user - user id to get deployed expressions for
 * @param supabaseClient - (optional) The supabaseClient. If using in a load fn, pass in the client from the load event. Otherwise if this is happening client side, the function will create a client for you.
 */
export const getDeployedExpressionsForUser = async (
	user: Database['public']['Tables']['profiles']['Row'],
	supabaseClient?: TypedSupabaseClient
) => {
	if (!supabaseClient) supabaseClient = _supabaseClient;

	const walletsQuery = await supabaseClient.from('wallets').select('*').eq('user_id', user.id);

	if (!walletsQuery.data) return null;

	const wallets = walletsQuery.data.map((wallet) => wallet.address?.toLowerCase());

	//	Only mumbai at the moment
	const client = createClient({
		url: Subgraphs[0].endpoints.expressions
	});

	const { data, error } = await client.query(QueryAccountsFromArray, { wallets }).toPromise();

	if (error || data.accounts.length == 0) return null;
	const sgUserExpressions = data.accounts[0].expressions;

	// get all the interpreters in the db that match any of the interpreters used by the user's deployed expressions
	const matchedInterpreters = await matchInterpreters(
		sgUserExpressions.map((expression: any) =>
			expression.event.expression.interpreterInstance.id.toLowerCase()
		),
		supabaseClient
	);
	// console.log(matchedInterpreters)

	// get all the contracts in the db that match any of the senders for the expressions
	const matchedContracts = await matchContracts(
		sgUserExpressions.map((expression: any) => expression.sender.id),
		supabaseClient
	);

	// create the final object to return
	const deployedExpressions = sgUserExpressions.map((expression: any) => ({
		sg: { ...expression },
		created_at: expression.event.timestamp * 1000,
		stateConfig: expression?.event?.expression?.config,
		interpreter: matchedInterpreters.find(
			(interpreter: any) =>
				interpreter.interpreteraddress.toLowerCase() ==
				expression.event.expression.interpreterInstance.id.toLowerCase()
		),
		contract: matchedContracts.find(
			(contract: any) =>
				contract.contract_address.toLowerCase() == expression.sender.id.toLowerCase()
		)
	}));

	return deployedExpressions;
};

/**
 * Queries the expression sg by address, then queries the db to match the contract and interpreter used.
 * Returns the combined results.
 *
 * @param address - the address of the expression
 * @param supabaseClient - (optional) The supabaseClient. If using in a load fn, pass in the client from the load event. Otherwise if this is happening client side, the function will create a client for you.
 *
 */
export const getDeployedExpressionByAddress = async (
	address: string,
	supabaseClient?: TypedSupabaseClient
) => {
	if (!supabaseClient) supabaseClient = _supabaseClient;

	//	query the sg
	const client = createClient({
		url: Subgraphs[0].endpoints.expressions
	});

	const { data, error } = await client.query(QueryExpression, { address }).toPromise();
	if (error) throw sveltekitError(500, 'Not found');

	const userQuery = await supabaseClient
		.from('wallets')
		.select('*, user_id (*)')
		.eq('address', ethers.utils.getAddress(data.expression.account.id))
		.single();
	if (error) throw sveltekitError(500, 'Not found');

	const [contract] = await matchContracts([data.expression.sender.id], supabaseClient);
	const [interpreter] = await matchInterpreters(
		[data.expression.interpreterInstance.id],
		supabaseClient
	);

	return {
		sg: data.expression,
		user: userQuery?.data?.user_id,
		expression: { contract, interpreter, stateConfig: data.expression.config }
	};
};

/**
 * Copy a value to the clipboard and emit a toast message.
 *
 * @param value - the value to copy to the clipboard
 * @param message - the message to emit in the toast
 */
export const copyAndEmit = async (value: string, message: string) => {
	await navigator.clipboard.writeText(value);
	toast.push(message);
};
